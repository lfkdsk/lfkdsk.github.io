<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>自动机 on lfkdsk&#39;s Blog</title>
    <link>https://lfkdsk.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
    <description>Recent content in 自动机 on lfkdsk&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Mon, 11 Jul 2016 07:59:17 +0000</lastBuildDate>
    
	<atom:link href="https://lfkdsk.github.io/tags/%E8%87%AA%E5%8A%A8%E6%9C%BA/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用DFA做文本编辑器的自动提示</title>
      <link>https://lfkdsk.github.io/dfa-auto-suggestion/</link>
      <pubDate>Mon, 11 Jul 2016 07:59:17 +0000</pubDate>
      
      <guid>https://lfkdsk.github.io/dfa-auto-suggestion/</guid>
      <description>之前看龙书的时候，龙书提到可以在编译器里用动态的生成的NFA自动机来动态匹配自己的输入串，NFA的简单实现其实写起来非常简单，但是我是实际凭感觉写完之后，却觉得并不是非常的好用，在处理自己已经输入过的串，如果还要处理空串和一个符号对应多种路径就势必涉及回溯，所以我就动态生成了一个DFA，应该不是最简的，但是也能满足需求。
DFA状态 package sample; import java.util.ArrayList; import java.util.HashMap; import java.util.Map; /** * Dfa 状态 * * @author liufengkai * Created by liufengkai on 16/7/10. */ public class DfaState implements Comparable&amp;lt;DfaState&amp;gt; { private static int DFA_ID_COUNT = 0; /** * state id */ private int stateId; /** * transition set * char / set of dfaState */ private Map&amp;lt;Integer, DfaState&amp;gt; transitionSet; private DfaState parentState; private Integer parentInput; /** * 构造方法 * * @param input 输入串 * @param parentState 父节点 */ public DfaState(Integer input, DfaState parentState) { this.</description>
    </item>
    
  </channel>
</rss>