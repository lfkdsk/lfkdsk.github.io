<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="Hugo 0.91.2" name="generator"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="Intra-Mind Traveler" name="author"/>
<meta content="https://lfkdsk.github.io/make-new-language-3/" property="og:url"/>
<link href="https://lfkdsk.github.io/make-new-language-3/" rel="canonical"/><link href="./img/favicon.ico" rel="apple-touch-icon"/>
<link href="./img/favicon.ico" rel="icon"/>
<link href="./img/favicon.ico" rel="shortcut"/><script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/lfkdsk.github.io"
      },
      "articleSection" : "",
      "name" : "学习制作一门有趣的编程语言－0x03",
      "headline" : "学习制作一门有趣的编程语言－0x03",
      "description" : "分析一个C语言的Lex \u0026amp; Yacc 程序 博客地址： http:\/\/lfkdsk.github.io\n代码地址： https:\/\/github.com\/lfkdsk\/CodeParse\n本节我们来分析一个能匹配C语言的Lex \u0026amp; Yacc 程序\n Lex文件:http:\/\/www.lysator.liu.se\/c\/ANSI-C-grammar-l.html\nYacc文件:http:\/\/www.lysator.liu.se\/c\/ANSI-C-grammar-y.html\n 也可以直接在我的github代码地址中进行下载。\n先来分析Lex文件 D\t[0-9] L\t[a-zA-Z_] H\t[a-fA-F0-9] E\t[Ee][\u002b-]?{D}\u002b FS\t(f|F|l|L) IS\t(u|U|l|L)* 首先定义了一些正则式，这些正则的功能都是一目了然的。他们都不是完整的功能性的定义，而是为了下文组装方便的。其中FS \\ IS 的作用是在数字跟在后面的尾缀（浮点型、无符号、长整形之类的）。\n\u0026#34;\/*\u0026#34;\t{ comment(); } 第16行匹配了C语言的注释开始，并且调用了comment()函数。\ncomment() { char c, c1; loop: while ((c = input()) != \u0026#39;*\u0026#39; \u0026amp;\u0026amp; c != 0) putchar(c); if ((c1 = input()) != \u0026#39;\/\u0026#39; \u0026amp;\u0026amp; c != 0) { unput(c1); goto loop; } if (c !",
      "inLanguage" : "en-US",
      "author" : "Intra-Mind Traveler",
      "creator" : "Intra-Mind Traveler",
      "publisher": "Intra-Mind Traveler",
      "accountablePerson" : "Intra-Mind Traveler",
      "copyrightHolder" : "Intra-Mind Traveler",
      "copyrightYear" : "2016",
      "datePublished": "2016-06-01 22:28:06 \u002b0000 UTC",
      "dateModified" : "2016-06-01 22:28:06 \u002b0000 UTC",
      "url" : "https:\/\/lfkdsk.github.io\/make-new-language-3\/",
      "keywords" : [ "编程语言","Blog", "lfkdsk's Blog", "lfkdsk", "刘丰恺" ]
  }
</script>
<title>学习制作一门有趣的编程语言－0x03 - lfkdsk's Blog</title>
<meta content="学习制作一门有趣的编程语言－0x03 - lfkdsk's Blog" property="og:title"/>
<meta content="article" property="og:type"/>
<meta content="分析一个C语言的Lex &amp; Yacc 程序 博客地址： http://lfkdsk.github.io
代码地址： https://github.com/lfkdsk/CodeParse
本节我们来分析一个能匹配C语言的Lex &amp; Yacc 程序
 Lex文件:http://www.lysator.liu.se/c/ANSI-C-grammar-l.html
Yacc文件:http://www.lysator.liu.se/c/ANSI-C-grammar-y.html
 也可以直接在我的github代码地址中进行下载。
先来分析Lex文件 D	[0-9] L	[a-zA-Z_] H	[a-fA-F0-9] E	[Ee][+-]?{D}+ FS	(f|F|l|L) IS	(u|U|l|L)* 首先定义了一些正则式，这些正则的功能都是一目了然的。他们都不是完整的功能性的定义，而是为了下文组装方便的。其中FS \ IS 的作用是在数字跟在后面的尾缀（浮点型、无符号、长整形之类的）。
&quot;/*&quot;	{ comment(); } 第16行匹配了C语言的注释开始，并且调用了comment()函数。
comment() { char c, c1; loop: while ((c = input()) != '*' &amp;&amp; c != 0) putchar(c); if ((c1 = input()) != '/' &amp;&amp; c != 0) { unput(c1); goto loop; } if (c !" name="description"/>
<link href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker" rel="stylesheet"/>
<link href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/androidstudio.min.css" rel="stylesheet"/>
<link href="/css/paper.css" rel="stylesheet"/>
<link href="/css/index.css" rel="stylesheet"/>
<link href="/index.xml" rel="alternate" title="lfkdsk's Blog" type="application/rss+xml"/>
<link href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet"/>
<script>
    

    (function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-8TMSDJG47Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8TMSDJG47Q');
</script>
</head>
<body>
<article class="post Chinese" id="article">
<div class="row">
<div class="paper col-xs-12 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2">
<a href="/">
<div class="head-line"></div>
</a>
<header class="post-header">
<h1 class="post-title">学习制作一门有趣的编程语言－0x03</h1>
<div class="row">
<div class="col-xs-6">
<time class="post-date" datetime="2016-06-01 22:28:06 UTC">
                  01 Jun 2016
                </time>
</div>
<div class="col-xs-6">
<div class="post-author">
<a href="https://lfkdsk.github.io/" target="_blank">@Intra-Mind Traveler</a>
</div>
</div>
</div>
</header>
<div class="post-content markdown-body">
<h2 id="分析一个c语言的lex--yacc-程序">分析一个C语言的Lex &amp; Yacc 程序</h2>
<p><code>博客地址</code>： <a href="http://lfkdsk.github.io">http://lfkdsk.github.io</a><br/>
<code>代码地址</code>： <a href="https://github.com/lfkdsk/CodeParse">https://github.com/lfkdsk/CodeParse</a></p>
<p>本节我们来分析一个能匹配C语言的Lex &amp; Yacc 程序</p>
<blockquote>
<p><code>Lex文件</code>:http://www.lysator.liu.se/c/ANSI-C-grammar-l.html</p>
<p><code>Yacc文件</code>:http://www.lysator.liu.se/c/ANSI-C-grammar-y.html</p>
</blockquote>
<p>也可以直接在我的github代码地址中进行下载。</p>
<h3 id="先来分析lex文件">先来分析Lex文件</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">D			[<span style="color:#ae81ff">0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>]
L			[a<span style="color:#f92672">-</span>zA<span style="color:#f92672">-</span>Z_]
H			[a<span style="color:#f92672">-</span>fA<span style="color:#f92672">-</span>F0<span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>]
E			[Ee][<span style="color:#f92672">+-</span>]<span style="color:#f92672">?</span>{D}<span style="color:#f92672">+</span>
FS			(f<span style="color:#f92672">|</span>F<span style="color:#f92672">|</span>l<span style="color:#f92672">|</span>L)
IS			(u<span style="color:#f92672">|</span>U<span style="color:#f92672">|</span>l<span style="color:#f92672">|</span>L)<span style="color:#f92672">*</span>

</code></pre></div><p>首先定义了一些正则式，这些正则的功能都是一目了然的。他们都不是完整的功能性的定义，而是为了下文组装方便的。其中<code>FS</code> \ <code>IS</code> 的作用是在数字跟在后面的尾缀（浮点型、无符号、长整形之类的）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#e6db74">"/*"</span>			{ comment(); }
</code></pre></div><p>第16行匹配了C语言的注释开始，并且调用了<code>comment()</code>函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">comment()
{
	<span style="color:#66d9ef">char</span> c, c1;

loop:
	<span style="color:#66d9ef">while</span> ((c <span style="color:#f92672">=</span> input()) <span style="color:#f92672">!=</span> <span style="color:#e6db74">'*'</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
		putchar(c);

	<span style="color:#66d9ef">if</span> ((c1 <span style="color:#f92672">=</span> input()) <span style="color:#f92672">!=</span> <span style="color:#e6db74">'/'</span> <span style="color:#f92672">&amp;&amp;</span> c <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
	{
		unput(c1);
		<span style="color:#66d9ef">goto</span> loop;
	}

	<span style="color:#66d9ef">if</span> (c <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
		putchar(c1);
}
</code></pre></div><p><code>comment()</code>函数只做了一件事就是找到这个注释的结尾以判断这真的是一个注释，因为是注释，函数没有返回值，lex里面也没有对应的调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#e6db74">"auto"</span>			{ count(); <span style="color:#66d9ef">return</span>(AUTO); }
<span style="color:#e6db74">"break"</span>			{ count(); <span style="color:#66d9ef">return</span>(BREAK); }
<span style="color:#e6db74">"case"</span>			{ count(); <span style="color:#66d9ef">return</span>(CASE); }
<span style="color:#e6db74">"char"</span>			{ count(); <span style="color:#66d9ef">return</span>(CHAR); }
<span style="color:#e6db74">"const"</span>			{ count(); <span style="color:#66d9ef">return</span>(CONST); }
...
</code></pre></div><p>18-49行定义了C语言的内置关键字他们都调用了一个<code>count()</code>返回了一个对应的Token。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> column <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">count</span>()
{
	<span style="color:#66d9ef">int</span> i;

	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; yytext[i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">'\0'</span>; i<span style="color:#f92672">++</span>)
		<span style="color:#66d9ef">if</span> (yytext[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">'\n'</span>)
			column <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (yytext[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">'\t'</span>)
			column <span style="color:#f92672">+=</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">-</span> (column <span style="color:#f92672">%</span> <span style="color:#ae81ff">8</span>);
		<span style="color:#66d9ef">else</span>
			column<span style="color:#f92672">++</span>;

	ECHO;
}

</code></pre></div><p>这段函数在每次匹配之后记录了当前行中的具体位置(每当\n时换行\t时计算位置)。</p>
<p><code>ECHO</code>是一段宏：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Copy whatever the last rule matched to the standard output. */</span>
<span style="color:#75715e">#ifndef ECHO
</span><span style="color:#75715e"></span><span style="color:#75715e">/* This used to be an fputs(), but since the string might contain NUL's,
</span><span style="color:#75715e"> * we now use fwrite().
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">#define ECHO fwrite( yytext, yyleng, 1, yyout )
</span><span style="color:#75715e">#endif
</span></code></pre></div><p>51-62一些类型匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#75715e">// 这是C中变量名的定义
</span><span style="color:#75715e"></span>{L}({L}<span style="color:#f92672">|</span>{D})<span style="color:#f92672">*</span>		{ count(); <span style="color:#66d9ef">return</span>(check_type()); }
<span style="color:#75715e">// 16进制数
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0</span>[xX]{H}<span style="color:#f92672">+</span>{IS}<span style="color:#f92672">?</span>		{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
<span style="color:#75715e">// 各种数字
</span><span style="color:#75715e"></span><span style="color:#ae81ff">0</span>{D}<span style="color:#f92672">+</span>{IS}<span style="color:#f92672">?</span>		{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
{D}<span style="color:#f92672">+</span>{IS}<span style="color:#f92672">?</span>		{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
<span style="color:#75715e">// 字符
</span><span style="color:#75715e"></span>L<span style="color:#f92672">?</span><span style="color:#960050;background-color:#1e0010">'</span>(<span style="color:#960050;background-color:#1e0010">\\</span>.<span style="color:#f92672">|</span>[<span style="color:#f92672">^</span><span style="color:#960050;background-color:#1e0010">\\'</span>])<span style="color:#f92672">+</span><span style="color:#960050;background-color:#1e0010">'</span>	{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
<span style="color:#75715e">// 科学计数法
</span><span style="color:#75715e"></span>{D}<span style="color:#f92672">+</span>{E}{FS}<span style="color:#f92672">?</span>		{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
{D}<span style="color:#f92672">*</span><span style="color:#e6db74">"."</span>{D}<span style="color:#f92672">+</span>({E})<span style="color:#f92672">?</span>{FS}<span style="color:#f92672">?</span>	{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
{D}<span style="color:#f92672">+</span><span style="color:#e6db74">"."</span>{D}<span style="color:#f92672">*</span>({E})<span style="color:#f92672">?</span>{FS}<span style="color:#f92672">?</span>	{ count(); <span style="color:#66d9ef">return</span>(CONSTANT); }
<span style="color:#75715e">// 字符串
</span><span style="color:#75715e"></span>L<span style="color:#f92672">?</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">"(</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">.|[^</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">"</span>])<span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#e6db74">"	{ count(); return(STRING_LITERAL); }</span>
</code></pre></div><p><code>check_type()</code>中对类型进行检查。</p>
<p>Lex就只有这么多了。</p>
<h3 id="再来分析yacc文件">再来分析Yacc文件</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c"><span style="color:#f92672">%</span>token IDENTIFIER CONSTANT STRING_LITERAL SIZEOF
<span style="color:#f92672">%</span>token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
<span style="color:#f92672">%</span>token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
<span style="color:#f92672">%</span>token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
<span style="color:#f92672">%</span>token XOR_ASSIGN OR_ASSIGN TYPE_NAME

<span style="color:#f92672">%</span>token TYPEDEF EXTERN STATIC AUTO REGISTER
<span style="color:#f92672">%</span>token CHAR SHORT INT LONG SIGNED UNSIGNED FLOAT DOUBLE CONST VOLATILE VOID
<span style="color:#f92672">%</span>token STRUCT UNION ENUM ELLIPSIS

<span style="color:#f92672">%</span>token CASE DEFAULT IF ELSE LOWER_THAN_ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN

<span style="color:#f92672">%</span>start translation_unit

<span style="color:#f92672">%</span>nonassoc LOWER_THAN_ELSE 
<span style="color:#f92672">%</span>nonassoc ELSE
</code></pre></div><p>这里我们定义了一些关键字的Token，重点看最后两行<code>LOWER_THAN_ELSE</code> 和<code>ELSE</code>分别代表了两种的ELSE的优先级，用于处理ELSE常见的悬空冲突问题。</p>
<p>接下来我们看看yacc文件中的BNF式都是怎么写的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">primary_expression
	: IDENTIFIER
	<span style="color:#f92672">|</span> CONSTANT
	<span style="color:#f92672">|</span> STRING_LITERAL
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'('</span> expression <span style="color:#e6db74">')'</span>
	;
</code></pre></div><p>最小的子集由ID，常量，字符串，还有括号覆盖的表达式构成。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">postfix_expression
	: primary_expression
	<span style="color:#f92672">|</span> postfix_expression <span style="color:#e6db74">'['</span> expression <span style="color:#e6db74">']'</span>
	<span style="color:#f92672">|</span> postfix_expression <span style="color:#e6db74">'('</span> <span style="color:#e6db74">')'</span>
	<span style="color:#f92672">|</span> postfix_expression <span style="color:#e6db74">'('</span> argument_expression_list <span style="color:#e6db74">')'</span>
	<span style="color:#f92672">|</span> postfix_expression <span style="color:#e6db74">'.'</span> IDENTIFIER
	<span style="color:#f92672">|</span> postfix_expression PTR_OP IDENTIFIER
	<span style="color:#f92672">|</span> postfix_expression INC_OP
	<span style="color:#f92672">|</span> postfix_expression DEC_OP
	;
</code></pre></div><p>这个指出了postfix_expression可以代表数组，函数调用，带参数的函数调用，.表达式，-&gt;指针，++,–。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">argument_expression_list
	: assignment_expression
	<span style="color:#f92672">|</span> argument_expression_list <span style="color:#e6db74">','</span> assignment_expression
	;

unary_expression
	: postfix_expression
	<span style="color:#f92672">|</span> INC_OP unary_expression
	<span style="color:#f92672">|</span> DEC_OP unary_expression
	<span style="color:#f92672">|</span> unary_operator cast_expression
	<span style="color:#f92672">|</span> SIZEOF unary_expression
	<span style="color:#f92672">|</span> SIZEOF <span style="color:#e6db74">'('</span> type_name <span style="color:#e6db74">')'</span>
	;
</code></pre></div><p>参数表达式列表由多个',‘和assignment_expression组成，其实就是函数的多个传参。</p>
<p>一元表达式包含之前的postfix还有前置的++, –。还有就是对一个东西求sizeof也是。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">unary_operator
	: <span style="color:#e6db74">'&amp;'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'*'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'+'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'-'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'~'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'!'</span>
	;
</code></pre></div><p>一元运算符。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">cast_expression
	: unary_expression
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'('</span> type_name <span style="color:#e6db74">')'</span> cast_expression
	;

multiplicative_expression
	: cast_expression
	<span style="color:#f92672">|</span> multiplicative_expression <span style="color:#e6db74">'*'</span> cast_expression
	<span style="color:#f92672">|</span> multiplicative_expression <span style="color:#e6db74">'/'</span> cast_expression
	<span style="color:#f92672">|</span> multiplicative_expression <span style="color:#e6db74">'%'</span> cast_expression
	;

additive_expression
	: multiplicative_expression
	<span style="color:#f92672">|</span> additive_expression <span style="color:#e6db74">'+'</span> multiplicative_expression
	<span style="color:#f92672">|</span> additive_expression <span style="color:#e6db74">'-'</span> multiplicative_expression
	;
</code></pre></div><p>cast_expression:强制类型转换</p>
<p>multiplicative_expression/additive_expression:区分这五种运算的优先级。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">shift_expression
	: additive_expression
	<span style="color:#f92672">|</span> shift_expression LEFT_OP additive_expression
	<span style="color:#f92672">|</span> shift_expression RIGHT_OP additive_expression
	;

relational_expression
	: shift_expression
	<span style="color:#f92672">|</span> relational_expression <span style="color:#e6db74">'&lt;'</span> shift_expression
	<span style="color:#f92672">|</span> relational_expression <span style="color:#e6db74">'&gt;'</span> shift_expression
	<span style="color:#f92672">|</span> relational_expression LE_OP shift_expression
	<span style="color:#f92672">|</span> relational_expression GE_OP shift_expression
	;

equality_expression
	: relational_expression
	<span style="color:#f92672">|</span> equality_expression EQ_OP relational_expression
	<span style="color:#f92672">|</span> equality_expression NE_OP relational_expression
	;
</code></pre></div><p>shift-&gt;位运算 ；relational_expression 处理比较；equality_expression 处理相等关系。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">and_expression
	: equality_expression
	<span style="color:#f92672">|</span> and_expression <span style="color:#e6db74">'&amp;'</span> equality_expression
	;

exclusive_or_expression
	: and_expression
	<span style="color:#f92672">|</span> exclusive_or_expression <span style="color:#e6db74">'^'</span> and_expression
	;

inclusive_or_expression
	: exclusive_or_expression
	<span style="color:#f92672">|</span> inclusive_or_expression <span style="color:#e6db74">'|'</span> exclusive_or_expression
	;

logical_and_expression
	: inclusive_or_expression
	<span style="color:#f92672">|</span> logical_and_expression AND_OP inclusive_or_expression
	;

logical_or_expression
	: logical_and_expression
	<span style="color:#f92672">|</span> logical_or_expression OR_OP logical_and_expression
	;

conditional_expression
	: logical_or_expression
	<span style="color:#f92672">|</span> logical_or_expression <span style="color:#e6db74">'?'</span> expression <span style="color:#e6db74">':'</span> conditional_expression
	;
</code></pre></div><p>下面是几种逻辑运算符的匹配关系，还有三目运算符。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">assignment_expression
	: conditional_expression
	<span style="color:#f92672">|</span> unary_expression assignment_operator assignment_expression
	;

assignment_operator
	: <span style="color:#e6db74">'='</span>
	<span style="color:#f92672">|</span> MUL_ASSIGN
	<span style="color:#f92672">|</span> DIV_ASSIGN
	<span style="color:#f92672">|</span> MOD_ASSIGN
	<span style="color:#f92672">|</span> ADD_ASSIGN
	<span style="color:#f92672">|</span> SUB_ASSIGN
	<span style="color:#f92672">|</span> LEFT_ASSIGN
	<span style="color:#f92672">|</span> RIGHT_ASSIGN
	<span style="color:#f92672">|</span> AND_ASSIGN
	<span style="color:#f92672">|</span> XOR_ASSIGN
	<span style="color:#f92672">|</span> OR_ASSIGN
	;

expression
	: assignment_expression
	<span style="color:#f92672">|</span> expression <span style="color:#e6db74">','</span> assignment_expression
	;

constant_expression
	: conditional_expression
	;

declaration
	: declaration_specifiers <span style="color:#e6db74">';'</span>
	<span style="color:#f92672">|</span> declaration_specifiers init_declarator_list <span style="color:#e6db74">';'</span>
	;

declaration_specifiers
	: storage_class_specifier
	<span style="color:#f92672">|</span> storage_class_specifier declaration_specifiers
	<span style="color:#f92672">|</span> type_specifier
	<span style="color:#f92672">|</span> type_specifier declaration_specifiers
	<span style="color:#f92672">|</span> type_qualifier
	<span style="color:#f92672">|</span> type_qualifier declaration_specifiers
	;
</code></pre></div><p>assignment_operator 指定了一类缩略形式，诸如：/= *= += -=之类的。</p>
<p>declaration 添加了‘;’</p>
<p>declaration_specifiers定义了类型的声明。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">init_declarator_list
	: init_declarator
	<span style="color:#f92672">|</span> init_declarator_list <span style="color:#e6db74">','</span> init_declarator
	;

init_declarator
	: declarator
	<span style="color:#f92672">|</span> declarator <span style="color:#e6db74">'='</span> initializer
	;

storage_class_specifier
	: TYPEDEF
	<span style="color:#f92672">|</span> EXTERN
	<span style="color:#f92672">|</span> STATIC
	<span style="color:#f92672">|</span> AUTO
	<span style="color:#f92672">|</span> REGISTER
	;
</code></pre></div><p>storage_class_specifier 定义了几种类型。init_declarator完成了初始化。</p>
<p>init_declarator_list ‘,’ init_declarator 是在对于多个同类型的参数的初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">type_specifier
	: VOID
	<span style="color:#f92672">|</span> CHAR
	<span style="color:#f92672">|</span> SHORT
	<span style="color:#f92672">|</span> INT
	<span style="color:#f92672">|</span> LONG
	<span style="color:#f92672">|</span> FLOAT
	<span style="color:#f92672">|</span> DOUBLE
	<span style="color:#f92672">|</span> SIGNED
	<span style="color:#f92672">|</span> UNSIGNED
	<span style="color:#f92672">|</span> struct_or_union_specifier
	<span style="color:#f92672">|</span> enum_specifier
	<span style="color:#f92672">|</span> TYPE_NAME
	;

struct_or_union_specifier
	: struct_or_union IDENTIFIER <span style="color:#e6db74">'{'</span> struct_declaration_list <span style="color:#e6db74">'}'</span>
	<span style="color:#f92672">|</span> struct_or_union <span style="color:#e6db74">'{'</span> struct_declaration_list <span style="color:#e6db74">'}'</span>
	<span style="color:#f92672">|</span> struct_or_union IDENTIFIER
	;

struct_or_union
	: STRUCT
	<span style="color:#f92672">|</span> UNION
	;
</code></pre></div><p>type_specifier 中定义了很多的数据类型。struct_or_union是结构体和联合的定义。</p>
<p>struct_or_union_specifier 给出了对结构体的定义。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">struct_declaration_list
	: struct_declaration
	<span style="color:#f92672">|</span> struct_declaration_list struct_declaration
	;

struct_declaration
	: specifier_qualifier_list struct_declarator_list <span style="color:#e6db74">';'</span>
	;

specifier_qualifier_list
	: type_specifier specifier_qualifier_list
	<span style="color:#f92672">|</span> type_specifier
	<span style="color:#f92672">|</span> type_qualifier specifier_qualifier_list
	<span style="color:#f92672">|</span> type_qualifier
	;
</code></pre></div><p>继续给出了一些结构体的申请。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">struct_declarator_list
	: struct_declarator
	<span style="color:#f92672">|</span> struct_declarator_list <span style="color:#e6db74">','</span> struct_declarator
	;

struct_declarator
	: declarator
	<span style="color:#f92672">|</span> <span style="color:#e6db74">':'</span> constant_expression
	<span style="color:#f92672">|</span> declarator <span style="color:#e6db74">':'</span> constant_expression
	;

enum_specifier
	: ENUM <span style="color:#e6db74">'{'</span> enumerator_list <span style="color:#e6db74">'}'</span>
	<span style="color:#f92672">|</span> ENUM IDENTIFIER <span style="color:#e6db74">'{'</span> enumerator_list <span style="color:#e6db74">'}'</span>
	<span style="color:#f92672">|</span> ENUM IDENTIFIER
	;

enumerator_list
	: enumerator
	<span style="color:#f92672">|</span> enumerator_list <span style="color:#e6db74">','</span> enumerator
	;

enumerator
	: IDENTIFIER
	<span style="color:#f92672">|</span> IDENTIFIER <span style="color:#e6db74">'='</span> constant_expression
	;
</code></pre></div><p>struct_declarator_list 是多个结构体的申请过程。</p>
<p>struct_declarator 结构体的声明符。</p>
<p>constant_expression 指向了一些逻辑表达式。</p>
<p>enum_specifier 定义了联合的声明，同样list就是多个同类型的声明，emumerator是对结构体的初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">type_qualifier
	: CONST
	<span style="color:#f92672">|</span> VOLATILE
	;

declarator
	: pointer direct_declarator
	<span style="color:#f92672">|</span> direct_declarator
	;

direct_declarator
	: IDENTIFIER
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'('</span> declarator <span style="color:#e6db74">')'</span>
	<span style="color:#f92672">|</span> direct_declarator <span style="color:#e6db74">'['</span> constant_expression <span style="color:#e6db74">']'</span>
	<span style="color:#f92672">|</span> direct_declarator <span style="color:#e6db74">'['</span> <span style="color:#e6db74">']'</span>
	<span style="color:#f92672">|</span> direct_declarator <span style="color:#e6db74">'('</span> parameter_type_list <span style="color:#e6db74">')'</span>
	<span style="color:#f92672">|</span> direct_declarator <span style="color:#e6db74">'('</span> identifier_list <span style="color:#e6db74">')'</span>
	<span style="color:#f92672">|</span> direct_declarator <span style="color:#e6db74">'('</span> <span style="color:#e6db74">')'</span>
	;
</code></pre></div><p>type_qualifier 定义了const 和 volatile 关键字。</p>
<p>declarator 声明符指向了指针类型和基础类型。</p>
<p>direct_declarator 直接声明符，包含了数组、带参数的函数返回值，等等等。</p>
<p>pointer 指针类型。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">pointer
	: <span style="color:#e6db74">'*'</span>
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'*'</span> type_qualifier_list
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'*'</span> pointer
	<span style="color:#f92672">|</span> <span style="color:#e6db74">'*'</span> type_qualifier_list pointer
	;

type_qualifier_list
	: type_qualifier
	<span style="color:#f92672">|</span> type_qualifier_list type_qualifier
	;


parameter_type_list
	: parameter_list
	<span style="color:#f92672">|</span> parameter_list <span style="color:#e6db74">','</span> ELLIPSIS
	;
</code></pre></div><p>pointer 指明了几种指针的书写方式。</p>
<p>parameter_type_list 代表参数列表。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4" tabindex="0"><code class="language-c" data-lang="c">		<span style="color:#75715e">/* 这里的无else的优先级是低于由else 的 */</span>
selection_statement
	: IF <span style="color:#e6db74">'('</span> expression <span style="color:#e6db74">')'</span> statement <span style="color:#f92672">%</span>prec LOWER_THAN_ELSE
	<span style="color:#f92672">|</span> IF <span style="color:#e6db74">'('</span> expression <span style="color:#e6db74">')'</span> statement ELSE statement
	<span style="color:#f92672">|</span> SWITCH <span style="color:#e6db74">'('</span> expression <span style="color:#e6db74">')'</span> statement
	;
</code></pre></div><p>其余的只有这里值得注意一下，这里出现了著名的ELSE悬空的移进规约bug，所以使用了一个优先级低于ELSE的LOWER_THAN_ELSE来指定优先级。</p>
</div>
<p>Subscribe：<a href="https://lfkdsk.github.io/index.xml" target="_blank">lfkdsk's Blog</a></p>
<div style="height:50px"></div>
<div class="post-comments">
<div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://lfkdsk.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript>Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>
</div>
</article>
<script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>
</body>
</html>
