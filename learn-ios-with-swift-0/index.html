<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.53" />

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="lfkdsk" />
  <meta property="og:url" content="https://lfkdsk.github.io/learn-ios-with-swift-0/" />
  <link rel="canonical" href="https://lfkdsk.github.io/learn-ios-with-swift-0/" />

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https://lfkdsk.github.io"
      },
      "articleSection" : "",
      "name" : "Learn iOS With Swift 0",
      "headline" : "Learn iOS With Swift 0",
      "description" : "Swift之初见 let常量值 let 表示定义好的常量值，并不一定在编译期确定但是的确只能被初始化一次。
let lfkdsk = 1000 // 直接初始化 let lfkdsk : Int // 没有直接初始化要提供类型推倒 lfkdsk = 100 let lfkdsk = 100 + String(1000) // 类型转化要使用显示转换 let apple = 1000 let lfkdsk = &quot;lfkdsk have \(apple) apples&quot; // 类比Ruby的${}  字典和元组 var shoppingList = [&quot;fuck &quot;,&quot;you&quot;] var occupations = [&quot;S&quot;:&quot;M&quot;,&quot;F&quot;,&quot;Y&quot;] occupations[&quot;F&quot;] = xxx // 这些都很好理解  // 创建空数组合字典 可以写出类型 let emptyArray = [String]() // 但是初始化之后就不能再修改了 let emptyDictionary = [String: Float]()  类型可以显示推断的话用:",
      "inLanguage" : "en-US",
      "author" : "lfkdsk",
      "creator" : "lfkdsk",
      "publisher": "lfkdsk",
      "accountablePerson" : "lfkdsk",
      "copyrightHolder" : "lfkdsk",
      "copyrightYear" : "2016",
      "datePublished": "2016-12-20 22:01:11 &#43;0000 UTC",
      "dateModified" : "2016-12-20 22:01:11 &#43;0000 UTC",
      "url" : "https://lfkdsk.github.io/learn-ios-with-swift-0/",
      "keywords" : [ "iOS Swift","Blog", "Joway's Blog", "Joway" ]
  }
</script>

  <title>Learn iOS With Swift 0 - lfkdsk&#39;s Blog</title>
  <meta property="og:title" content="Learn iOS With Swift 0 - lfkdsk&#39;s Blog" />
  <meta property="og:type" content="article" />
  <meta name="description" content="Swift之初见 let常量值 let 表示定义好的常量值，并不一定在编译期确定但是的确只能被初始化一次。
let lfkdsk = 1000 // 直接初始化 let lfkdsk : Int // 没有直接初始化要提供类型推倒 lfkdsk = 100 let lfkdsk = 100 &#43; String(1000) // 类型转化要使用显示转换 let apple = 1000 let lfkdsk = &quot;lfkdsk have \(apple) apples&quot; // 类比Ruby的${}  字典和元组 var shoppingList = [&quot;fuck &quot;,&quot;you&quot;] var occupations = [&quot;S&quot;:&quot;M&quot;,&quot;F&quot;,&quot;Y&quot;] occupations[&quot;F&quot;] = xxx // 这些都很好理解  // 创建空数组合字典 可以写出类型 let emptyArray = [String]() // 但是初始化之后就不能再修改了 let emptyDictionary = [String: Float]()  类型可以显示推断的话用:" />

  <link
    href="https://fonts.googleapis.com/css?family=Arvo|Permanent+Marker"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/flexboxgrid@6.3.1/dist/flexboxgrid.min.css"
  />

  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/androidstudio.min.css"
  />

  <link
  rel="stylesheet"
  href="/css/paper.css"
  />

  <link rel="stylesheet" href="/css/index.css">

  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="lfkdsk&#39;s Blog">
  
  <script>
    

    (function(undefined) {}).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});
  </script>

  
</head>


  <body>
    <article class="post Chinese" id="article">
      <div class="row">
        <div class="paper col-xs-12 col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2">
          <a href="/">
            <div class="head-line"></div>
          </a>
          <header class="post-header">
            <h1 class="post-title">Learn iOS With Swift 0</h1>
            <div class="row">
              <div class="col-xs-6">
                <time class="post-date" datetime="2016-12-20 22:01:11 UTC">
                  20 Dec 2016
                </time>
              </div>
              <div class="col-xs-6">
                <div class="post-author">
                  <a target="_blank" href="https://lfkdsk.github.io/">@lfkdsk</a>
                </div>
              </div>
            </div>
          </header>
          <div class="to-top">
            <a href="#top" class="paper-btn margin">^</a>
          </div> 
          <div class="post-content markdown-body">
            

<h1 id="swift之初见">Swift之初见</h1>

<h2 id="let常量值">let常量值</h2>

<p>let 表示定义好的常量值，并不一定在编译期确定但是的确只能被初始化一次。</p>

<pre><code class="language-swift">let lfkdsk = 1000 // 直接初始化
let lfkdsk : Int // 没有直接初始化要提供类型推倒
lfkdsk = 100
let lfkdsk = 100 + String(1000) // 类型转化要使用显示转换
let apple = 1000
let lfkdsk = &quot;lfkdsk have \(apple) apples&quot; // 类比Ruby的${}
</code></pre>

<h2 id="字典和元组">字典和元组</h2>

<pre><code class="language-swift">var shoppingList = [&quot;fuck &quot;,&quot;you&quot;]
var occupations = [&quot;S&quot;:&quot;M&quot;,&quot;F&quot;,&quot;Y&quot;]
occupations[&quot;F&quot;] = xxx
// 这些都很好理解
</code></pre>

<pre><code class="language-swift">// 创建空数组合字典 可以写出类型
let emptyArray = [String]() // 但是初始化之后就不能再修改了
let emptyDictionary = [String: Float]()
</code></pre>

<p>类型可以显示推断的话用:</p>

<pre><code class="language-swift">shoppingList = []
occupations = [:]
</code></pre>

<h2 id="条件控制">条件控制</h2>

<p>使用if和switch来进行条件操作，使用for-in、for、while和repeat-while来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。</p>

<p>后加<code>？</code>表示可选变量</p>

<pre><code class="language-swift">let nickName: String? = nil
let fullName: String = &quot;John Appleseed&quot;
// 另一种提供默认值的方式
let informalGreeting = &quot;Hi \(nickName ?? fullName)”
</code></pre>

<p>Swich语句支持多种类型和表达式，无需<code>break</code>但是不可缺少<code>default</code>:</p>

<pre><code class="language-swift">let vegetable = &quot;red pepper&quot;
switch vegetable {
case &quot;celery&quot;:
    print(&quot;Add some raisins and make ants on a log.&quot;)
case &quot;cucumber&quot;, &quot;watercress&quot;:
    print(&quot;That would make a good tea sandwich.&quot;)
case let x where x.hasSuffix(&quot;pepper&quot;):
    print(&quot;Is it a spicy \(x)?&quot;)
default:
    print(&quot;Everything tastes good in soup.&quot;)
}
</code></pre>

<p><code>for-in</code>语句，可设定key-value值的样子：</p>

<pre><code class="language-swift">let interestingNumbers = [
    &quot;Prime&quot;: [2, 3, 5, 7, 11, 13],
    &quot;Fibonacci&quot;: [1, 1, 2, 3, 5, 8],
    &quot;Square&quot;: [1, 4, 9, 16, 25],
]
var largest = 0
for (kind, numbers) in interestingNumbers {
    for number in numbers {
        if number &gt; largest {
            largest = number
        }
    }
}
</code></pre>

<p><code>while</code>语句：</p>

<pre><code class="language-swift">var n = 2
while n &lt; 100 {
    n = n * 2
}
print(n)
 
var m = 2
repeat {
    m = m * 2
} while m &lt; 100
print(m)
// 你可以在循环中使用..&lt;来表示范围。

var total = 0
for i in 0..&lt;4 { // 0...&lt;4包含上界
    total += i
}
print(total)
</code></pre>

<h2 id="函数和闭包">函数和闭包</h2>

<pre><code class="language-swift">func greet(name: String, day: String) -&gt; String {
    return &quot;Hello \(name), today is \(day).&quot;
}
greet(name:&quot;Bob&quot;, day: &quot;Tuesday&quot;)
</code></pre>

<p>如代码所示，使用参数调用函数，使用<code>-&gt;</code>设定返回值（总的来说语法很类似）。</p>

<pre><code class="language-swift">func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0
    for score in scores {
        if score &gt; max {
            max = score
        } else if score &lt; min {
            min = score
        }
        sum += score
    }
    return (min, max, sum)
}
let statistics = calculateStatistics(scores:[5, 3, 100, 3, 9])
print(statistics.sum)
print(statistics.2)
</code></pre>

<p>返回多个返回值。</p>

<pre><code class="language-swift">func sumOf(numbers: Int...) -&gt; Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(numbers: 42, 597, 12)
</code></pre>

<p>可变参数，这个和很多语言都很类似。</p>

<p>可定义函数内函数，作用域包含外界，所以也可以传递函数：</p>

<pre><code class="language-swift">func makeIncrementer() -&gt; ((Int) -&gt; Int) {
    func addOne(number: Int) -&gt; Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
</code></pre>

<pre><code class="language-swift">func hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -&gt; Bool {
    return number &lt; 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
</code></pre>

<p>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{}来创建一个匿名闭包。使用in将参数和返回值类型声明与闭包函数体进行分离。</p>

<pre><code class="language-swift">numbers.map({
    (number: Int) -&gt; Int in // 匿名闭包 使用 in 区分
    let result = 3 * number
    return result
})
</code></pre>

<pre><code class="language-swift">var numbers = [20, 19, 7, 12]

numbers.map({
    (number :Int) -&gt; (Bool) in
    let result  = number % 2 != 0;
    return result;
})

numbers.sort{ $0 &gt; $1}

print(numbers)
</code></pre>

<h2 id="类和对象">类和对象</h2>

<pre><code class="language-swift">class Shape {
    var numberOfSides = 0
    func simpleDescription() -&gt; String {
        return &quot;A shape with \(numberOfSides) sides.&quot;
    }
}

var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
</code></pre>

<p>类中的<code>init</code>和<code>deinit</code>函数是构造函数和析构函数。</p>

<p>子类在类名后添加父类的名称，函数重载需要加<code>override</code>标签。</p>

<pre><code class="language-swift">class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0
 
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }
 
    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3
           }
    }
 
    override func simpleDescription() -&gt; String {
        return &quot;An equilateral triagle with sides of length \(sideLength).&quot;
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)
print(triangle.perimeter)
triangle.perimeter = 9.9
print(triangle.sideLength)
</code></pre>

<p>构造器执行了三步：</p>

<ol>
<li>设置子类声明的属性值</li>
<li>调用父类的构造器</li>
<li>改变父类的属性值，其他的工作如调用方法，<code>getters</code>和<code>setters</code>也可以在这个阶段完成。</li>
</ol>

<pre><code class="language-swift">class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)
print(triangleAndSquare.square.sideLength)
print(triangleAndSquare.triangle.sideLength)
triangleAndSquare.square = Square(sideLength: 50, name: &quot;larger square&quot;)
print(triangleAndSquare.triangle.sideLength)
</code></pre>

<p>处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加?。如果?之前的值是nil，?后面的东西都会被忽略，并且整个表达式返回nil。否则，?之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。</p>

<pre><code class="language-swift">let optionalSquare: Square? = Square(sideLength: 2.5, name: &quot;optional square&quot;)
let sideLength = optionalSquare?.sideLength
</code></pre>

<h2 id="枚举和结构体">枚举和结构体</h2>

<pre><code class="language-swift">enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -&gt; String {
    switch self {
        case .Ace:
            return &quot;ace&quot;
        case .Jack:
            return &quot;jack&quot;
        case .Queen:
            return &quot;queen&quot;
        case .King:
            return &quot;king&quot;
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.Ace
let aceRawValue = ace.rawValue
</code></pre>

<p>枚举可以包含方法。</p>

<p><code>struct</code>的使用：</p>

<pre><code class="language-swift">struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -&gt; String {
        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;
    }
}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</code></pre>

<p>结构体和类的区别是，结构体是传值，类是传引用。</p>

<pre><code class="language-swift">enum ServerResponse {
    case Result(String, String)
    case Failure(String)
}
// 实例和原始值
let success = ServerResponse.Result(&quot;6:00 am&quot;, &quot;8:09 pm&quot;)
let failure = ServerResponse.Failure(&quot;Out of cheese.&quot;)
 
switch success {
case let .Result(sunrise, sunset):
    let serverResponse = &quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;
case let .Failure(message):
    print(&quot;Failure...  \(message)&quot;)
}
</code></pre>

<h2 id="协议和扩展">协议和扩展</h2>

<p>使用protocol来声明一个协议，就是interface，protocol这种命名真是奇怪。</p>

<p>使用<code>mutating</code>来标记Struct中改变内容的值，使用<code>extension</code>拓展一个类的内容。</p>

<pre><code class="language-swift">protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
class SimpleClass: ExampleProtocol {
    var simpleDescription: String = &quot;A very simple class.&quot;
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += &quot;  Now 100% adjusted.&quot;
    }
}
extension Int: ExampleProtocol {
    var simpleDescription: String {
        return &quot;The number \(self)&quot;
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)
</code></pre>

<h2 id="错误处理">错误处理</h2>

<p>嗯，首先有Error这个Interface来代表错误信息。</p>

<p>函数后标记<code>throw</code>表示可以抛出错误。</p>

<p>错误处理：</p>

<pre><code class="language-swift">func sendToPrinter(printerName: String) throws -&gt; String {
    if printerName == &quot;Never Has Toner&quot; {
        throw PrinterError.NoToner
    }
    return &quot;Job sent&quot;
}

do {
    let printerResponse = try sendToPrinter(&quot;Bi Sheng&quot;)
    print(printerResponse)
} catch {
    print(error)
} 
</code></pre>

<pre><code class="language-swift">let printerSuccess = try? sendToPrinter(&quot;Mergenthaler&quot;)
let printerFailure = try? sendToPrinter(&quot;Never Has Toner&quot;)
</code></pre>

<p><code>defer</code>绑定函数结尾，写到这，我觉得swift越来越像golang了。</p>

<pre><code class="language-swift">var fridgeIsOpen = false
let fridgeContent = [&quot;milk&quot;, &quot;eggs&quot;, &quot;leftovers&quot;]
 
func fridgeContains(_ food: String) -&gt; Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }
 
    let result = fridgeContent.contains(food)
    return result
}
fridgeContains(&quot;banana&quot;)
print(fridgeIsOpen)
</code></pre>

<h2 id="泛型">泛型</h2>

<pre><code class="language-swift">func repeatItem&lt;Item&gt;(repeating item: Item, numberOfTimes: Int) -&gt; [Item] {
    var result = [Item]()
    for _ in 0..&lt;numberOfTimes {
        result.append(item)
    }
    return result
}
repeatItem(repeating: &quot;knock&quot;, numberOfTimes:4)
</code></pre>

<p>返回一个泛型数组，使用<code>where</code>子句实现泛型的特化。</p>

          </div>
          
          <div class="post-comments">
            <div id="disqus_thread"></div>
<script>
  window.addEventListener("load", () => {
    (function() {
      
      var d = document,
        s = d.createElement("script");
      s.src = "https://lfkdsk.disqus.com/embed.js";
      s.setAttribute("data-timestamp", +new Date());
      (d.head || d.body).appendChild(s);
    })();
  });
</script>
<noscript
  >Please enable JavaScript to view the
  <a href="https://disqus.com/?ref_noscript"
    >comments powered by Disqus.</a
  ></noscript
>

          </div>
          
        </div>
      </div>
    </article>

    <script src="/js/highlight.pack.js"></script>
<script src="https://unpkg.com/quicklink@0.1.1/dist/quicklink.umd.js"></script>

<script>
  hljs.initHighlightingOnLoad();
  
  var posts = document.getElementById('posts-list');
  posts && quicklink({
    el: posts,
    priority: true,
  });
</script>

  </body>
</html>
